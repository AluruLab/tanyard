#!/usr/bin/perl

# $Id: csv2exp 597 2010-06-23 01:06:56Z zola $
#
# File: csv2exp
# Developed: Feb 21, 2009
#
# Author: Jaroslaw Zola <jaroslaw.zola@gmail.com>
#
# Copyright 2007-2010 Jaroslaw Zola
#
# This file is part of TINGe.
#
# TINGe is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# TINGe is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with TINGe. If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;
use Getopt::Long;


my $usage = "usage: csv2exp [options] infile [outfile]
options:
  --map map_file     map file to get probe aliases
  --match            insert probe name when probe has no alias (default false)
  --del              text delimiter (default none)
  --sep              field separator (default \"\\t\")\n";

die $usage if (@ARGV == 0);

my $mapfile = "";
my $match = 0;
my $del = "";
my $sep = "\t";
my $ARGS = join(' ', @ARGV);

GetOptions('map=s' => \$mapfile, 'match!' => \$match, 'del=s' => \$del, 'sep=s' => \$sep);

die $usage if (@ARGV == 0);

my $infile = $ARGV[0];
my $outfile = "";

if (defined $ARGV[1]) { $outfile = $ARGV[1]; }
else {
    ($outfile = $infile) =~ s/\....$//;
    $outfile .= ".exp";
}

# get map
my %map;

if ($mapfile ne "") {
    open(MAP, "< $mapfile") or die "error: can't open map file\n";
    while (<MAP>) {
	chomp($_);
	my ($probe, $alias) = split(" ", $_);
	die "error: data corrupted\n" if ((not defined $probe) or (not defined $alias));
	$map{$probe} = $alias;
    }
    close(MAP);
}

# process
open(INPUT, "< $infile") or die "error: can't open input file\n";
open(OUTPUT, "> $outfile") or die "error: can't open output file\n";

# check first two lines
my $tmp1 = <INPUT>;
my $tmp2 = <INPUT>;
die "error: can't read input file\n" unless ((defined $tmp1) && (defined $tmp2));

chomp($tmp1);
my @l1 = split($sep, $tmp1);

chomp($tmp2);
my @l2 = split($sep, $tmp2);

my $len = 0;

if (scalar(@l1) == scalar(@l2)) { ($len = scalar(@l1) - 1) }
else {
    die "error: header corrupted\n" if (scalar(@l1) != (scalar(@l2) - 1));
    $len = scalar(@l1);
}

seek(INPUT, 0, 0);

# rewrite header
my $out_head = "Id\tAlias\t";

my $tmp = <INPUT>;
chomp($tmp);
$tmp =~ s/$del//g;

my @line = split($sep, $tmp);
shift @line if ($len < scalar(@line));
$line[0] =~ s/^\s*//;

$out_head = $out_head . join("\t", @line);

print OUTPUT "$out_head\n";
print OUTPUT "Description\tGenerated by: csv2exp $ARGS\n";
print OUTPUT "Description\t";
print OUTPUT `date`;

# rewrite data
while (<INPUT>) {
    chomp($_);
    s/$del//g;

    @line = split($sep, $_);
    my $name = $line[0];

    shift @line;
    die "error: data corrupted\n" if (scalar(@line) != $len);

    my $alias = ($mapfile ne "") ? "no_match" : "---";
    $alias = $map{$name} if (defined $map{$name});
    $alias = $name if (($alias eq "no_match") && ($match == 1));

    print OUTPUT "$name\t$alias\t" . join("\t", @line) . "\n";
}

close(OUTPUT);
close(INPUT);
